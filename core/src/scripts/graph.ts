/*  --------------------
 *  Graph - Alibaba
 *  (c) Kingcean Tuan, 2014.
 *
 *  File  graph.ts
 *  Description  Graph library.
 *  Owner  Kingcean Tuan <kingcean@live.com>
 *  --------------------  */

/// <reference path="common.ts" />

namespace AliHub.Graph {

    /*
     * The box size and position contract.
     */
    export interface SizePositionContract extends Common.PlaneCoordinate {

        /*
         * Gets or sets the width.
         */
        width?: number;

        /*
         * Gets or sets the height.
         */
        height?: number;
    }

    /*
     * The position in a line contract.
     */
    export interface PositionInLineContract extends Common.PlaneCoordinate {

        /*
         * Gets or sets the distance percents from top-left corner.
         */
        rate: number;

        /*
         * Gets or sets the side (up, right, down and left).
         */
        side: Elements.PeripheralOrientations;
    }

    /*
     * The line ends contract.
     */
    export interface LineEndsContract {

        /*
         * The start position in a line.
         */
        start: PositionInLineContract;

        /*
         * The end position in a line.
         */
        end: PositionInLineContract;
    }

    /**
      * Series chart information.
      */
    export interface SeriesChartContract {
        categories: string[];
        data: Collection.KeyValuePairContract<string, number>;
        highligh?: Collection.IntervalContract<number>[];
        scope?: Collection.IntervalContract<number>;
    }

    /**
      * String with color.
      */
    export interface ColorStringContract {

        /**
          * String color.
          */
        color?: string;

        /**
          * Background color.
          */
        bgColor?: string;

        /**
          * Charactors to show.
          */
        value: string;

        /**
          * Style reference key.
          */
        styleRef?: string | string[];

        /**
          * Additional properties.
          */
        [property: string]: any;

    }

    /**
      * Image reference.
      */
    export interface ImageContract {

        /**
          * Image type - url, string, svg.
          */
        type: string;

        /**
          * Style reference key.
          */
        styleRef?: string | string[];

        /**
          * Additional properties.
          */
        [property: string]: any;

    }

    /**
      * Image generated by charactors.
      * type should be string.
      */
    export interface StringImageContract extends ImageContract, ColorStringContract {
    }

    /**
      * Image generated by URL.
      * type should be url.
      */
    export interface UrlImageContract extends ImageContract {

        /**
          * String name.
          */
        name?: string;

        /**
          * Image URL.
          */
        url: string;

    }

    /**
      * Image generated by SVG.
      * type should be svg.
      */
    export interface SvgImageContract extends ImageContract {

        /**
          * SVG source.
          */
        source: string;

    }

    /**
      * Line options.
      */
    export interface LineOptionsContract {
        highlight?: number;
        max?: number;
        min?: number;
    }

    /**
      * Pie options.
      */
    export interface PieOptionsContract {
        innerSize?: string;
    }

    function svgToImage(svg: SVGElement) {
        var image = document.createElement("img");
        image.src = "";
        var canvas = document.createElement("canvas");
        canvas.getContext("2d").drawImage(image, 0, 0);
        return {
            type: "url",
            url: canvas.toDataURL("image/png")
        };
    }

    /**
      * Generates an element for image.
      * image  the image contract.
      */
    export function imageElement(value: ImageContract | Common.BindingObjectContract<ImageContract>): HTMLElement {
        if (!value) return null;
        var image = value as ImageContract;
        if (!(<any>value).type && !!(<any>value).subscribe) image = (<Common.BindingObjectContract<ImageContract>>value)();
        if (!image || !image.type) return null;
        var styleRefs = Collection.toStringArray(image.styleRef, true);
        switch (image.type.toString().toLowerCase()) {
            case "url": {
                var urlImg = image as UrlImageContract;
                var imgEle = document.createElement("img");
                if (!!urlImg.url) imgEle.src = urlImg.url;
                if (!!urlImg.name) imgEle.alt = urlImg.name;
                imgEle.className = "ali-image-icon";
                if (!!image.styleRef) for (var item in styleRefs) {
                    imgEle.className += " " + styleRefs[item];
                }

                return imgEle;
            }
            case "string": {
                var strImg = image as StringImageContract;
                var spanEle = document.createElement("span");
                spanEle.innerHTML = strImg.value;
                spanEle.style.color = strImg.color;
                spanEle.style.backgroundColor = strImg.bgColor;
                spanEle.className = "ali-image-icon";
                if (!!image.styleRef) for (var item in styleRefs) {
                    spanEle.className += " " + styleRefs[item];
                }

                return spanEle;
            }
            case "svg":
                var svgImg = image as SvgImageContract;
                if (!svgImg.source) return null;
                try {
                    var svgEle = document.createElement("span");
                    var svgSource = svgImg.source.toString();
                    var sourceStart = svgSource.indexOf("<svg ");
                    if (svgSource === "" || sourceStart < 0) return null;
                    svgSource = svgSource.substring(sourceStart);
                    svgEle.innerHTML = svgSource;

                    var svgSrcEle = svgEle.children[0] as SVGElement;
                    if (!!image.styleRef && !!svgSrcEle && !!svgSrcEle.classList && !!svgSrcEle.classList.add) {
                        svgSrcEle.classList.add(...styleRefs);
                    }

                    return svgSrcEle as any;
                } catch (ex) {
                    return null;
                }
            default:
                return null;
        }
    }

    /*
      * Links given rectangles and dots by lines.
      */
    export function lines(boxes: SizePositionContract[]): LineEndsContract[] {
        if (!boxes) return [];
        var list: LineEndsContract[] = [];
        for (var i = 0; i < boxes.length - 1; i++) {
            var a = boxes[i];
            if (!a) {
                list.push(null);
                continue;
            }

            var next = 1;
            var b: SizePositionContract;
            while (next < boxes.length) {
                b = boxes[i + next];
                if (!!b) break;
                next++;
            }

            var aPos: PositionInLineContract = {
                x: a.x,
                y: a.y,
                rate: 50,
                side: Elements.PeripheralOrientations.Cover
            };
            var bPos: PositionInLineContract = {
                x: b.x,
                y: b.y,
                rate: 50,
                side: Elements.PeripheralOrientations.Cover
            };
            list.push({
                start: aPos,
                end: bPos
            });
            var distX = ((b.width || 0) - (a.width || 0)) / 2 + bPos.x - aPos.x;
            var distY = ((b.height || 0) - (a.height || 0)) / 2 + bPos.y - aPos.y;
            var isHorizontal = Math.abs(distX) > Math.abs(distY);

            if (a.width != null && a.height !== null) {
                if (isHorizontal) {
                    if (distX > 0) {
                        aPos.side = Elements.PeripheralOrientations.Right;
                        aPos.x += a.width;
                    } else {
                        aPos.side = Elements.PeripheralOrientations.Left;
                    }

                    var aHeightMin = a.height * 1.0 / 10;
                    if (distY > aHeightMin || distY < -aHeightMin) aPos.rate = distY > 0 ? 60 : 40;
                    aPos.y += a.height * aPos.rate / 100;
                } else {
                    if (distY > 0) {
                        aPos.side = Elements.PeripheralOrientations.Bottom;
                        aPos.y += a.height;
                    } else {
                        aPos.side = Elements.PeripheralOrientations.Top;
                    }

                    var aWidthMin = a.width * 1.0 / 10;
                    if (distX > aWidthMin || distX < -aWidthMin) aPos.rate = distX > 0 ? 60 : 40;
                    aPos.x += a.width * aPos.rate / 100;
                }
            }

            if (b.width != null && b.height !== null) {
                if (isHorizontal) {
                    if (distX > 0) {
                        bPos.side = Elements.PeripheralOrientations.Left;
                    } else {
                        bPos.side = Elements.PeripheralOrientations.Right;
                        bPos.x += b.width;
                    }

                    var bHeightMin = b.height * 1.0 / 10;
                    if (distY > bHeightMin || distY < -bHeightMin) bPos.rate = distY > 0 ? 40 : 60;
                    bPos.y += b.height * bPos.rate / 100;
                } else {
                    if (distY > 0) {
                        bPos.side = Elements.PeripheralOrientations.Top;
                    } else {
                        bPos.side = Elements.PeripheralOrientations.Bottom;
                        bPos.y += b.height;
                    }

                    var bWidthMin = b.width * 1.0 / 10;
                    if (distX > bWidthMin || distX < -bWidthMin) bPos.rate = distX > 0 ? 40 : 60;
                    bPos.x += b.width * bPos.rate / 100;
                }
            }
        }

        return list;
    }

    /**
      * Chart center.
      */
    export class Chart {

        /**
          * Generates an HTML string of progress bar.
          * value  the value.
          * blockCount  the count of block in progress bar.
          */
        public static genProgressBarHTML(value: number, blockCount: number): string {
            var str = "<svg class=\"chart-progress-img\" viewBox=\"0 0 104 20\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">"
                + "<title>Progress Bar</title><desc>Chart of progress bar.</desc><defs>"
                + "<linearGradient id=\"chart-progress-fill\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"><stop offset=\"0%\" class=\"chart-progress-fill-0\" /><stop offset=\"100%\" class=\"chart-progress-fill-100\" /></linearGradient>"
                + "</defs><g id=\"ProgressBar\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">"
                + "<g id=\"chart-progress-rec\" sketch:type=\"MSArtboardGroup\" >"
                + "<rect id=\"chart-progress-rec-b\" stroke=\"url(#chart-progress-fill)\" sketch:type=\"MSShapeGroup\" x=\"0\" y=\"0\" width=\"104\" height=\"20\" rx=\"4\" ry=\"4\"></rect>";
            var blockWidth = 100 / blockCount;
            var showCount = parseInt((value / blockWidth).toFixed())
            for (var step = 0; step < showCount; step++) {
                str += "<rect id=\"chart-progress-rec-f" + step.toString() + "\" fill=\"url(#chart-progress-fill)\" sketch:type=\"MSShapeGroup\" x=\"" + (step * blockWidth + 3).toString() + "\" y=\"2\" width=\"" + (blockWidth - 2).toString() + "\" height=\"16\" rx=\"2\" ry=\"2\"></rect>";
            }

            str += "</g></g></svg>";
            return str;
        }

        public static genIsoscelesRightTriangle(rotation: number): string {
            var x = (45 + rotation) * Math.PI / 180;
            var delta = Math.sin(Math.PI / 4);
            var sin = Math.sin(x);
            var cos = Math.cos(x);
            var ax = 100 * sin;
            var ay = 100 * (delta - cos);
            var degrees = rotation + 45;
            var str = "<svg version=\"1.1\" id=\"graph-polygon-tri-ir\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100px\" height=\"100px\" viewBox=\"0 0 100 100\" xml:space=\"preserve\"><polygon points=\"15,15 15,85 85,15\" fill=\"#CCC\" stroke=\"#CCC\" stroke-width=\"1\" transform=\"rotate("
                + degrees.toString()
                + " 50, 50)\"/></svg>";
            return str;
        }
    }

    /**
      * External extensions for graph.
      */
    export class Extensions {

        /**
          * Renders radar.
          */
        public static radar(element: HTMLElement, title: string, data: Collection.PropertiesContract<number>): void {
        }

        /**
          * Renders line.
          */
        public static line(element: HTMLElement, title: string, data: Collection.PropertiesContract<number>, options?: LineOptionsContract): void {
        }

        /**
          * Renders pie.
          */
        public static pie(element: HTMLElement, title: string, data: Collection.PropertiesContract<number>, options?: PieOptionsContract): void {
        }

    }

}
 